<!DOCTYPE html>
<html>
  <head>
    <title>3D Scatter Plot</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: white; /* Set the background color to white */
      }
      #chartContainer {
        width: 100%;
        height: 100vh;
      }
      #cameraPosition {
        position: absolute;
        top: 10px;
        left: 10px;
        color: red;
      }
    </style>
  </head>
  <body>
    <div id="cameraPosition"></div>
    <div id="chartContainer"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/controls/OrbitControls.js"></script>

    <script>
      // Declare global variables
      let scene, camera, font;
      const gridSizeX = 16; // Number of columns
      const gridSizeY = 7; // Number of rows
      const cubeSize = 0.4;

      // Function to create a single cube
      function createCube(x, y, z, size, color) {
        const geometry = new THREE.BoxGeometry(size, size, size);
        const material = new THREE.MeshPhongMaterial({ color });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y + size / 2, z);
        return cube;
      }

      // Function to create the grid
      function createGrid() {
        const gridTexture = new THREE.TextureLoader().load(
          "https://threejs.org/examples/textures/grid.png"
        );
        gridTexture.wrapS = THREE.RepeatWrapping;
        gridTexture.wrapT = THREE.RepeatWrapping;

        // Adjust the repeat values for rows and columns
        gridTexture.repeat.set(gridSizeX - 1, gridSizeY - 1);

        const floorGeometry = new THREE.PlaneGeometry(
          gridSizeX,
          gridSizeY,
          gridSizeX - 1,
          gridSizeY - 1
        );
        const floorMaterial = new THREE.MeshPhongMaterial({
          map: gridTexture,
          wireframe: true, // Display as wireframe
          color: 0xcccccc, // Set the floor color to grey
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);
      }

      // Function to display camera position
      function updateCameraPositionDisplay(camera) {
        const cameraPositionElement = document.getElementById("cameraPosition");
        const position = camera.position;
        const rotation = camera.rotation;

        // Round the values for display
        const posX = position.x.toFixed(2);
        const posY = position.y.toFixed(2);
        const posZ = position.z.toFixed(2);
        const rotX = THREE.MathUtils.radToDeg(rotation.x).toFixed(2);
        const rotY = THREE.MathUtils.radToDeg(rotation.y).toFixed(2);
        const rotZ = THREE.MathUtils.radToDeg(rotation.z).toFixed(2);

        // Update the HTML element
        cameraPositionElement.innerHTML = `
          Camera Position:<br>
          X: ${posX}, Y: ${posY}, Z: ${posZ}<br>
          Rotation X: ${rotX}, Y: ${rotY}, Z: ${rotZ}
        `;
      }

      function createYAxisLabels(yAxisValues) {
        for (let i = 0; i < yAxisValues.length; i++) {
          let yPoint = yAxisValues[i];
          var xValueToMap = yPoint.x; // This value is in the range [0, 140]
          var mappedXValue = mapValue(xValueToMap, 0, 150, 0, 1);
          var yValueToMap = yPoint.y; // This value is in the range [0, 120]
          var mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0; // You can adjust the vertical position if needed
          const z = (mappedYValue - 0.5) * gridSizeY;

          const labelGeometry = new THREE.TextGeometry(yPoint.label, {
            font: font,
            size: 0.2, // Adjust the size as needed
            height: 0.01, // Adjust the height as needed
          });

          const labelMaterial = new THREE.MeshBasicMaterial({
            color: 0x999999,
          });

          const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);

          // Rotate the label to be vertical
          labelMesh.rotation.x = -Math.PI / 2;

          const labelX = gridSizeX / 2 - cubeSize / 2 + 1.1; // Adjust the X position to right-align the text
          const labelY = 0;
          const labelZ = z;

          labelMesh.position.set(-8.75, labelY, labelZ);

          scene.add(labelMesh);
        }
      }

      function createXAxisLabels(xAxisValues) {
        for (let i = 0; i < xAxisValues.length; i++) {
          let xPoint = xAxisValues[i];
          var xValueToMap = xPoint.x; // This value is in the range [0, 150]
          var mappedXValue = mapValue(xValueToMap, 0, 150, 0, 1);
          var yValueToMap = xPoint.y; // This value is in the range [0, 120]
          var mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0; // You can adjust the vertical position if needed
          const z = (mappedYValue - 0.5) * gridSizeY;

          const labelGeometry = new THREE.TextGeometry(xPoint.label, {
            font: font,
            size: 0.2, // Adjust the size as needed
            height: 0.01, // Adjust the height as needed
          });

          const labelMaterial = new THREE.MeshBasicMaterial({
            color: 0x999999,
          });

          const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);

          // Rotate the label to be vertical
          labelMesh.rotation.x = -Math.PI / 2;

          const labelX = x;
          const labelY = 0;
          const labelZ = gridSizeY / 2 - cubeSize / 2 + 0.5; // Adjust the Z position to align with the bottom

          labelMesh.position.set(labelX, labelY, labelZ);

          scene.add(labelMesh);
        }
      }

      // In your createScatterPlot method, call createYAxisLabels
      function createScatterPlot(data) {
        scene = new THREE.Scene();
        scene.scale.set(0.5, 0.5, 0.5); // Adjust the scale as needed
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        document
          .getElementById("chartContainer")
          .appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        // Load the font using FontLoader
        const loader = new THREE.FontLoader();
        loader.load(
          "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
          function (loadedFont) {
            font = loadedFont; // Store the loaded font

            // Create cubes based on JSON data points
            for (let i = 0; i < data.length; i++) {
              const dataPoint = data[i];
              var xValueToMap = dataPoint.x; // This value is in the range [0, 140]
              var mappedXValue = mapValue(xValueToMap, 0, 150, 0, 1);
              var yValueToMap = dataPoint.y; // This value is in the range [0, 120]
              var mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

              const x = (mappedXValue - 0.5) * gridSizeX;
              const y = 0; // You can adjust the vertical position if needed
              const z = (mappedYValue - 0.5) * gridSizeY;

              console.log(x, y, z);

              const cube = createCube(x, y, z, cubeSize, dataPoint.color); // Adjust color as needed
              scene.add(cube);
            }

            // Define your yAxisValues using a loop
            let yAxisValues = [];
            for (let y = 100; y >= 0; y -= 20) {
              yAxisValues.push({
                x: 0,
                y,
                z: -3.3333333333333335,
                label: y.toString(),
              });
            }

            // Call the createYAxisLabels method
            createYAxisLabels(yAxisValues);

            // Define an array to store X-axis values
            const xAxisValues = [];

            // Create X-axis labels from 0 to 140 with a step of 10
            for (let x = 0; x <= 140; x += 10) {
              xAxisValues.push({ x, y: 0, label: x.toString() });
            }
            // Call the function to create X-axis labels
            createXAxisLabels(xAxisValues);

            // Lights
            const light1 = new THREE.DirectionalLight(0xffffff, 1);
            light1.position.set(1, 1, 1);
            scene.add(light1);

            const light2 = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(light2);

            camera.position.set(-3, 2, 5);

            const animate = function () {
              requestAnimationFrame(animate);
              renderer.render(scene, camera);
              controls.update();
              updateCameraPositionDisplay(camera);
            };

            createGrid();
            animate();
          }
        );
      }

      // Function to create the scatter plot
      function mapValue(value, min1, max1, min2, max2) {
        // Ensure the value is within the range [min1, max1]
        value = Math.min(Math.max(value, min1), max1);

        // Calculate the mapped value in the range [min2, max2]
        var mappedValue =
          ((value - min1) * (max2 - min2)) / (max1 - min1) + min2;

        return mappedValue;
      }

      function mapYValue(value, min1, max1, min2, max2) {
        // Ensure the value is within the range [min1, max1]
        value = Math.min(Math.max(value, min1), max1);

        // Calculate the mapped value in the inverted range [min2, max2]
        var mappedValue = (max1 - value) / (max1 - min1);

        return mappedValue;
      }

      // Initialize the scene with JSON data points
      const jsonData = [
        { x: 30, y: 90, color: 0x00fff, label: "A" },
        { x: 10, y: 60, color: 0x00fff, label: "B" },
        { x: 10, y: 10, color: 0x00fff, label: "A" },
        { x: 80, y: 80, color: 0x00fff, label: "B" },
        { x: 70, y: 110, color: 0x00fff, label: "A" },
      ];

      createScatterPlot(jsonData);
    </script>
  </body>
</html>
