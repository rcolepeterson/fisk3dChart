<!DOCTYPE html>
<!-- https://fiskalloy.com/products/alloy-explorer/ -->
<!-- https://github.com/rcolepeterson/testmechart/blob/labels/index.html#L140 -->
<html>
  <head>
    <title>3D Scatter Plot</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>
  <body>
    <div id="cameraPosition"></div>
    <div id="chartContainer"></div>
    <div id="info"></div>
    <!-- <div id="label"></div> -->
    <div id="dd">
      <div class="form-group-filters">
        <div>
          <label for="toggleAll">Show All</label>
          <label class="custom-checkbox toggle-all">
            <input
              type="radio"
              id="toggleAll"
              name="dataType"
              value="All"
              onclick="showAll()"
              checked
            />
            <span class="checkmark"></span>
          </label>
        </div>
        <div>
          <label for="toggleConductors">Alloy Conductors</label>
          <label class="custom-checkbox toggle-conductors">
            <input
              type="radio"
              id="toggleConductors"
              name="dataType"
              value="Alloy Conductors"
              onclick="showAlloyConductors()"
            />
            <span class="checkmark"></span>
          </label>
        </div>

        <div>
          <label for="toggleWire">Alloy Wire</label>
          <label class="custom-checkbox toggle-wire">
            <input
              type="radio"
              id="toggleWire"
              name="dataType"
              value="Alloy Wire"
              onclick="showAlloyWire()"
            />
            <span class="checkmark"></span>
          </label>
        </div>
        <div>
          <label for="toggleFineWire">Fine Wire</label>
          <label class="custom-checkbox toggle-fine-wire">
            <input
              type="radio"
              id="toggleFineWire"
              name="dataType"
              value="Fine Wire"
              onclick="showFineWire()"
            />
            <span class="checkmark"></span>
          </label>
        </div>
      </div>

      <!-- Add these dropdowns in your HTML -->
      <div class="form-group">
        <label for="minConductivity">Minimum Conductivity</label>
        <select id="minConductivity" class="minimal">
          <!-- Add options from 0 to 100 in increments of 10 -->
          <option value="0">0</option>
          <option value="10">10</option>
          <option value="20">20</option>
          <option value="30">30</option>
          <option value="40">40</option>
          <option value="50">50</option>
          <option value="60">60</option>
          <option value="70">70</option>
          <option value="80">80</option>
          <option value="90">90</option>
          <option value="100">100</option>
          <!-- Add more options as needed -->
        </select>
      </div>

      <div class="form-group">
        <label for="minTensileStrength">Minimum Tensile Strength</label>
        <select id="minTensileStrength" class="minimal">
          <!-- Add options from 0 to 200 in increments of 10 -->
          <option value="0">0</option>
          <option value="10">10</option>
          <option value="20">20</option>
          <option value="30">30</option>
          <option value="40">40</option>
          <option value="50">50</option>
          <option value="60">60</option>
          <option value="70">70</option>
          <option value="80">80</option>
          <option value="90">90</option>
          <option value="100">100</option>
          <option value="110">110</option>
          <option value="120">120</option>
          <option value="130">130</option>
          <option value="140">140</option>
          <option value="150">150</option>
          <option value="160">160</option>
          <option value="170">170</option>
          <option value="180">180</option>
          <option value="190">190</option>
          <option value="200">200</option>
          <!-- Add more options as needed -->
        </select>
      </div>

      <div class="form-group-filters">
        <div>
          <label for="flex_life">Flex Life</label>
          <label class="custom-checkbox flex-life">
            <input
              type="checkbox"
              id="flex_life"
              name="dataType"
              value="flex_life"
              class="performance-checkbox"
            />
            <span class="checkmark"></span>
          </label>
        </div>

        <div>
          <label for="soft_resistance">Softing Resistance</label>
          <label class="custom-checkbox soft-resistance">
            <input
              type="checkbox"
              id="soft_resistance"
              name="dataType"
              value="soft_resistance"
              class="performance-checkbox"
            />
            <span class="checkmark"></span>
          </label>
        </div>
        <div>
          <label for="stress_relaxation">Stress Relaxation</label>
          <label class="custom-checkbox stress-relaxation">
            <input
              type="checkbox"
              id="stress_relaxation"
              name="dataType"
              value="stress_relaxation"
              class="performance-checkbox"
            />
            <span class="checkmark"></span>
          </label>
        </div>
        <div>
          <label for="spring_properties">Spring Properties</label>
          <label class="custom-checkbox spring-properties">
            <input
              type="checkbox"
              id="spring_properties"
              name="dataType"
              value="spring_properties"
              class="performance-checkbox"
            />
            <span class="checkmark"></span>
          </label>
        </div>

        <div>
          <label for="formability">Formability</label>
          <label class="custom-checkbox formability">
            <input
              type="checkbox"
              id="formability"
              name="dataType"
              value="formability"
              class="performance-checkbox"
            />
            <span class="checkmark"></span>
          </label>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/controls/OrbitControls.js"></script>

    <script>
      // Declare global variables
      let scene, camera, font;
      const gridSizeX = 16; // Number of columns
      const gridSizeY = 7; // Number of rows
      const cubeSize = 0.4;
      // Assuming cubeSize is defined somewhere above
      const baseCubeHeight = cubeSize;

      // Store the initial window size
      let initialWindowWidth = window.innerWidth;
      let initialWindowHeight = window.innerHeight;

      // Load the font using FontLoader at the beginning
      const loader = new THREE.FontLoader();
      loader.load(
        "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
        function (loadedFont) {
          font = loadedFont;
          // Continue with loading JSON data
          loadJSONData();
        }
      );

      // Function to show only Alloy Conductors
      function showAlloyConductors() {
        cubes.forEach((cube) => {
          // Hide all cubes
          cube.visible = false;
          if (cube.userData.labelElement) {
            cube.userData.labelElement.style.display = "none";
          }
          // Show only Alloy Conductors cubes
          if (cube.userData.type.includes("Alloy Conductors")) {
            cube.visible = true;
            if (cube.userData.labelElement) {
              cube.userData.labelElement.style.display = "block";
            }
          }
        });
        // Update visibility of associated stacked cubes
        allCubes.forEach((c) => {
          c.visible =
            cubes.find((cube) => cube.userData.id === c.userData.baseCubeId)
              ?.visible || false;
        });
      }

      // Function to show only Alloy Wire
      function showAlloyWire() {
        cubes.forEach((cube) => {
          // Hide all cubes
          cube.visible = false;
          if (cube.userData.labelElement) {
            cube.userData.labelElement.style.display = "none";
          }
          // Show only Alloy Wire cubes
          if (cube.userData.type.includes("Alloy Wire")) {
            cube.visible = true;
            if (cube.userData.labelElement) {
              cube.userData.labelElement.style.display = "block";
            }
          }
        });
        // Update visibility of associated stacked cubes
        allCubes.forEach((c) => {
          c.visible =
            cubes.find((cube) => cube.userData.id === c.userData.baseCubeId)
              ?.visible || false;
        });
      }
      // Function to show only Fine Wire
      function showFineWire() {
        cubes.forEach((cube) => {
          // Hide all cubes
          cube.visible = false;
          if (cube.userData.labelElement) {
            cube.userData.labelElement.style.display = "none";
          }
          // Show only Fine Wire cubes
          if (cube.userData.type.includes("Fine Wire")) {
            cube.visible = true;
            if (cube.userData.labelElement) {
              cube.userData.labelElement.style.display = "block";
            }
          }
        });
        // Update visibility of associated stacked cubes
        allCubes.forEach((c) => {
          c.visible =
            cubes.find((cube) => cube.userData.id === c.userData.baseCubeId)
              ?.visible || false;
        });
      }

      // Function to show all cubes
      function showAll() {
        cubes.forEach((cube) => {
          if (
            cube.userData.type.includes("Alloy Conductors") ||
            cube.userData.type.includes("Alloy Wire")
          ) {
            cube.visible = true;
            if (cube.userData.labelElement) {
              cube.userData.labelElement.style.display = "block";
            }
          } else if (cube.userData.type.includes("Fine Wire")) {
            cube.visible = false;
            if (cube.userData.labelElement) {
              cube.userData.labelElement.style.display = "none";
            }
          }
        });
        // Update visibility of associated stacked cubes
        allCubes.forEach((c) => {
          c.visible =
            cubes.find((cube) => cube.userData.id === c.userData.baseCubeId)
              ?.visible || false;
        });
      }

      // Function to display camera position
      function updateCameraPositionDisplay(camera) {
        const cameraPositionElement = document.getElementById("cameraPosition");
        const position = camera.position;
        const rotation = camera.rotation;

        // Round the values for display
        const posX = position.x.toFixed(2);
        const posY = position.y.toFixed(2);
        const posZ = position.z.toFixed(2);
        const rotX = THREE.MathUtils.radToDeg(rotation.x).toFixed(2);
        const rotY = THREE.MathUtils.radToDeg(rotation.y).toFixed(2);
        const rotZ = THREE.MathUtils.radToDeg(rotation.z).toFixed(2);

        // Update the HTML element
        cameraPositionElement.innerHTML = `
                Camera Position:<br>
                X: ${posX}, Y: ${posY}, Z: ${posZ}<br>
                Rotation X: ${rotX}, Y: ${rotY}, Z: ${rotZ}
              `;
      }

      // Function to filter data based on the selected checkboxes
      function filterData(dataTypes) {
        const minConductivity = Number(minConductivityDropdown.value);
        const minTensileStrength = Number(minTensileStrengthDropdown.value);
        console.log(minConductivity, minTensileStrength);
        scene.children.forEach((child) => {
          if (child.userData && child.userData.type) {
            // If the child is a base cube, check if it meets the minimum requirements
            if (child.userData.id !== undefined) {
              if (
                child.userData.y_conduct_e >= minConductivity &&
                child.userData.x_tensile_e >= minTensileStrength
              ) {
                child.visible = true;
              } else {
                child.visible = false;
              }
            } else {
              // If the child is not a base cube, apply the filter
              if (
                dataTypes[child.userData.type] &&
                child.userData.y_conduct_e >= minConductivity &&
                child.userData.x_tensile_e >= minTensileStrength
              ) {
                child.visible = true;
              } else {
                child.visible = false;
              }
            }
          }
        });

        // Then, if only "soft_resistance" is selected, adjust the y-position of the cubes
        if (dataTypes.soft_resistance && !dataTypes.flex_life) {
          // Get all the base cubes
          const baseCubes = scene.children.filter(
            (child) => child.userData.id !== undefined
          );

          baseCubes.forEach((baseCube) => {
            // Get all the "soft_resistance" cubes for this base cube
            const softResistanceCubes = scene.children.filter(
              (child) =>
                child.visible &&
                child.userData.type === "soft_resistance" &&
                child.userData.baseCubeId === baseCube.userData.id
            );

            // Sort the cubes by their original y-position
            softResistanceCubes.sort(
              (a, b) => a.userData.originalY - b.userData.originalY
            );

            // Adjust the y-position of each cube
            softResistanceCubes.forEach((cube, index) => {
              cube.position.y =
                baseCube.position.y +
                baseCubeHeight +
                cubeSize +
                index * cubeSize -
                0.5;
            });
          });
        } else {
          // If the other filter is added back in, reset the y-position of each cube
          scene.children.forEach((child) => {
            if (child.userData && child.userData.originalY) {
              child.position.y = child.userData.originalY;
            }
          });
        }
      }

      // Function to create a single cube
      function createCube(x, y, z, size, color, type) {
        const geometry = new THREE.BoxGeometry(size, size, size);
        const material = new THREE.MeshPhongMaterial({ color });
        const cube = new THREE.Mesh(geometry, material);

        cube.position.set(x, y + size / 2, z);
        // Add metadata indicating the type of data (e.g., "conductor", "alloy", "fire wire")
        cube.userData.type = type;
        return cube;
      }
      function createCubeHalf(x, y, z, size, color, type) {
        const geometry = new THREE.BoxGeometry(size, size / 2, size);
        const material = new THREE.MeshPhongMaterial({ color });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y + size / 2, z);
        // Add metadata indicating the type of data (e.g., "conductor", "alloy", "fire wire")
        cube.userData.type = type;
        return cube;
      }

      // Function to create the grid
      function createGrid() {
        const gridTexture = new THREE.TextureLoader().load(
          "https://threejs.org/examples/textures/grid.png"
        );
        gridTexture.wrapS = THREE.RepeatWrapping;
        gridTexture.wrapT = THREE.RepeatWrapping;

        // Adjust the repeat values for rows and columns
        gridTexture.repeat.set(gridSizeX - 1, gridSizeY - 1);

        const floorGeometry = new THREE.PlaneGeometry(
          gridSizeX,
          gridSizeY,
          gridSizeX - 1,
          gridSizeY - 1
        );
        const floorMaterial = new THREE.MeshPhongMaterial({
          map: gridTexture,
          wireframe: true, // Display as wireframe
          color: 0xffffff, // Set the floor color to grey
        });
        const yPosition = 0;
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, yPosition, 0);
        scene.add(floor);
      }

      // Function to display camera position
      function updateCameraPositionDisplay(camera) {
        const cameraPositionElement = document.getElementById("cameraPosition");
        const position = camera.position;
        const rotation = camera.rotation;

        // Round the values for display
        const posX = position.x.toFixed(2);
        const posY = position.y.toFixed(2);
        const posZ = position.z.toFixed(2);
        const rotX = THREE.MathUtils.radToDeg(rotation.x).toFixed(2);
        const rotY = THREE.MathUtils.radToDeg(rotation.y).toFixed(2);
        const rotZ = THREE.MathUtils.radToDeg(rotation.z).toFixed(2);

        // Update the HTML element
        cameraPositionElement.innerHTML = `
                            Camera Position:<br>
                            X: ${posX}, Y: ${posY}, Z: ${posZ}<br>
                            Rotation X: ${rotX}, Y: ${rotY}, Z: ${rotZ}
                          `;
      }

      function createYAxisLabels(yAxisValues) {
        for (let i = 0; i < yAxisValues.length; i++) {
          let yPoint = yAxisValues[i];
          var xValueToMap = yPoint.x; // This value is in the range [0, 140]
          var mappedXValue = mapXValue(xValueToMap, 0, 150, 0, 1);
          var yValueToMap = yPoint.y - 1.5; // This value is in the range [0, 120]
          var mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0; // You can adjust the vertical position if needed
          const z = (mappedYValue - 0.5) * gridSizeY;

          const labelGeometry = new THREE.TextGeometry(yPoint.label, {
            font: font,
            size: 0.2, // Adjust the size as needed
            height: 0.01, // Adjust the height as needed
          });

          const labelMaterial = new THREE.MeshBasicMaterial({
            color: 0x999999,
          });

          const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);

          // Rotate the label to be vertical
          labelMesh.rotation.x = -Math.PI / 2;

          const labelX = gridSizeX / 2 - cubeSize / 2 + 1.1; // Adjust the X position to right-align the text
          const labelY = 0;
          const labelZ = z;

          labelMesh.position.set(-8.75, labelY, labelZ);

          scene.add(labelMesh);
        }
      }

      function createXAxisLabels(xAxisValues) {
        for (let i = 0; i < xAxisValues.length; i++) {
          let xPoint = xAxisValues[i];
          var xValueToMap = xPoint.x - 1.5; // This value is in the range [0, 150]
          var mappedXValue = mapXValue(xValueToMap, 0, 150, 0, 1);
          var yValueToMap = xPoint.y; // This value is in the range [0, 120]
          var mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0; // You can adjust the vertical position if needed
          const z = (mappedYValue - 0.5) * gridSizeY;

          const labelGeometry = new THREE.TextGeometry(xPoint.label, {
            font: font,
            size: 0.2, // Adjust the size as needed
            height: 0.01, // Adjust the height as needed
          });

          const labelMaterial = new THREE.MeshBasicMaterial({
            color: 0x999999,
          });

          const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);

          // Rotate the label to be vertical
          labelMesh.rotation.x = -Math.PI / 2;

          const labelX = x;
          const labelY = 0;
          const labelZ = gridSizeY / 2 - cubeSize / 2 + 0.5; // Adjust the Z position to align with the bottom

          labelMesh.position.set(labelX, labelY, labelZ);

          scene.add(labelMesh);
        }
      }

      function createAxisLabels() {
        const xAxisLabelGeometry = new THREE.TextGeometry(
          "TENSILE STRENGTH (ksi)",
          {
            font: font,
            size: 0.3, // Adjust the size as needed
            height: 0.01, // Adjust the height as needed
          }
        );

        const yAxisLabelGeometry = new THREE.TextGeometry(
          "CONDUCTIVITY (% IACS @ 68°F)",
          {
            font: font,
            size: 0.3, // Adjust the size as needed
            height: 0.01, // Adjust the height as needed
          }
        );

        const labelMaterial = new THREE.MeshBasicMaterial({
          color: 0x999999,
        });

        const xAxisLabelMesh = new THREE.Mesh(
          xAxisLabelGeometry,
          labelMaterial
        );
        const yAxisLabelMesh = new THREE.Mesh(
          yAxisLabelGeometry,
          labelMaterial
        );

        // Rotate the labels to be vertical
        xAxisLabelMesh.rotation.x = -Math.PI / 2;
        //yAxisLabelMesh.rotation.x = -Math.PI / 2;

        // Rotate the Y-axis label to align with the Y-axis
        yAxisLabelMesh.rotation.x = -Math.PI / 2;
        yAxisLabelMesh.rotation.z = Math.PI / 2; // Rotate around the Z-axis

        // Position the labels at the midpoint of the respective axes
        // xAxisLabelMesh.position.set(0, gridSizeY / 2, gridSizeY / 2 - cubeSize / 2 + 0.5);
        // Position the labels at the midpoint of the respective axes
        const labelX = -2; // Midpoint of the X-axis
        const labelY = 0;
        const labelZ = 4.6; // Same Z position as the grid labels

        xAxisLabelMesh.position.set(labelX, labelY, labelZ);
        const yAxisLabelX = -gridSizeX / 2 - 1.2; // Left side of the X-axis
        const yAxisLabelY = 0;
        const yAxisLabelZ = 3; // Same Z position as the grid labels
        //console.log(gridSizeY / 2 - cubeSize / 2 + 0.5 );
        yAxisLabelMesh.position.set(yAxisLabelX, yAxisLabelY, yAxisLabelZ);

        scene.add(xAxisLabelMesh);
        scene.add(yAxisLabelMesh);
      }

      // Add the raycasting and click event handling code here
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      // Inside your animation loop, check for raycasting and mouse events
      const onDocumentMouseClick = (event) => {
        //console.log("we have clicked");
        event.preventDefault();

        // Calculate the mouse position in normalized device coordinates
        // (-1 to 1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Check for intersections with clickable objects (e.g., cubes)
        const intersects = raycaster.intersectObjects(scene.children, true);
        // console.log(intersects.length, "intersects");

        if (intersects.length > 0) {
          // Handle the click event for the clicked cube
          const clickedObject = intersects[0].object;
          //  console.log(clickedObject);

          if (clickedObject.userData.url) {
            window.open(clickedObject.userData.url, "_blank");
          }
        }
      };

      function createLabel(cube, i, labelContent) {
        // Create a label for the cube
        let labelElement = document.createElement("div");
        labelElement.id = `label-${i}`;
        labelElement.style.position = "absolute";
        labelElement.style.backgroundColor = "#d5d5d5";
        labelElement.className = "cube-label";
        cube.userData.labelElement = labelElement;

        // Create a wrapper for the normal state
        let normalContent = document.createElement("div");
        normalContent.className = "initial-content";
        normalContent.innerHTML = labelContent.product_shortname;
        let tensileValue = labelContent.x_tensile_e; // replace with actual value
        let conductivityValue = labelContent.y_conduct_e; // replace with actual value

        labelElement.appendChild(normalContent);

        let content = `<div class='content'>${labelContent.product_name}</div>
                          <div class='content'><span class='font-base'>Tensile: </span> ${tensileValue} ksi</div>
                          <div class='content'><span class='font-base'>Conductivity: </span>${conductivityValue} % IACS @ 68°F</div>
                          <div class='content click'>CLICK FOR MORE</div>`;

        // Create a wrapper for the hover state
        let hoverContent = document.createElement("div");
        hoverContent.innerHTML = content;
        hoverContent.style.display = "none"; // Hide it initially
        labelElement.appendChild(hoverContent);

        // Position the label at the base of the cube
        // This will depend on how your cubes are positioned and might require adjusting
        const vector = new THREE.Vector3();
        vector.setFromMatrixPosition(cube.matrixWorld);
        vector.project(camera);
        const labelX = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const labelY = (vector.y * -0.5 + 0.5) * window.innerHeight;
        labelElement.style.left = `${labelX}px`;
        labelElement.style.top = `${labelY}px`;

        labelElement.addEventListener("mouseover", function () {
          // Show hover state and hide normal state
          normalContent.style.display = "none";
          hoverContent.style.display = "block";
        });

        labelElement.addEventListener("mouseout", function () {
          // Show normal state and hide hover state
          normalContent.style.display = "block";
          hoverContent.style.display = "none";
        });

        labelElement.addEventListener("click", function () {
          // Navigate to product page
          window.location.href = "https://fiskalloy.com/";
        });

        document.body.appendChild(labelElement);
      }

      // Define an array to store your cubes
      let cubes = [];
      let allCubes = [];
      function createScatterPlot(data) {
        scene = new THREE.Scene();
        scene.scale.set(0.5, 0.5, 0.5); // Adjust the scale as needed
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        document
          .getElementById("chartContainer")
          .appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        data.forEach((dataPoint, i) => {
          const xValueToMap = dataPoint.x_tensile_e;
          const mappedXValue = mapXValue(xValueToMap, 0, 150, 0, 1);

          const yValueToMap = dataPoint.y_conduct_e;
          const mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0;
          const z = (mappedYValue - 0.5) * gridSizeY;
          const properties = [
            "flex_life",
            "soft_resistance",
            "stress_relaxation",
            "spring_properties",
            // "machinability",
            "formability",
          ];
          const colors = [
            "#bece71",
            "#697ba6",
            "#bece71",
            "#6cb2c4",
            // "#123152",
            "#cfc250",
          ];

          // Create base cube
          const baseCube = createCubeHalf(
            x,
            y,
            z,
            cubeSize,
            dataPoint.color[0],
            dataPoint.type[0]
          );
          baseCube.userData.url = dataPoint.product_url;
          baseCube.userData.y_conduct_e = dataPoint.y_conduct_e; // Add this line
          baseCube.userData.x_tensile_e = dataPoint.x_tensile_e;
          baseCube.userData.id = i;
          scene.add(baseCube);
          cubes.push(baseCube);
          createLabel(baseCube, i, dataPoint);

          // Create stacks based on properties
          let cubeY = y;
          properties.forEach((property, index) => {
            const numCubes = dataPoint[property];
            for (let j = 1; j <= numCubes; j++) {
              const cube = createCube(
                x,
                cubeY + j * cubeSize - 0.1,
                z,
                cubeSize,
                colors[index],
                property
              );
              cube.userData.url = dataPoint.product_url;
              cube.userData.y_conduct_e = dataPoint.y_conduct_e; // Add this line
              cube.userData.x_tensile_e = dataPoint.x_tensile_e;
              cube.userData.baseCubeId = i;
              cube.userData.originalY = cubeY + j * cubeSize + 0.1; // Store the original y-position for all cubes
              cube.visible = false;
              allCubes.push(cube);
              scene.add(cube);
            }
            cubeY += numCubes * cubeSize;
          });
        });

        // Define your yAxisValues using a loop
        let yAxisValues = [];
        for (let y = 100; y >= 0; y -= 20) {
          yAxisValues.push({
            x: 0,
            y,
            z: -3.3333333333333335,
            label: y.toString(),
          });
        }

        // Call the createYAxisLabels method
        createYAxisLabels(yAxisValues);

        // Define an array to store X-axis values
        const xAxisValues = [];

        // Create X-axis labels from 0 to 140 with a step of 10
        for (let x = 0; x <= 140; x += 10) {
          xAxisValues.push({ x, y: 0, label: x.toString() });
        }
        // Call the function to create X-axis labels
        createXAxisLabels(xAxisValues);

        // Lights
        const light1 = new THREE.DirectionalLight(0xffffff, 1);
        light1.position.set(1, 1, 1);
        scene.add(light1);

        const light2 = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(light2);
        // Lights
        // const light1 = new THREE.DirectionalLight(0xffffff, 0.75); // Reduced intensity to 0.75
        // light1.position.set(-1, 1, 1);
        // scene.add(light1);

        // const light2 = new THREE.AmbientLight(0xffffff, 0.25); // Reduced intensity to 0.25
        // scene.add(light2);

        // const light3 = new THREE.DirectionalLight(0xffffff, 0.5); // Reduced intensity to 0.5
        // light3.position.set(1, -1, 1);
        // scene.add(light3);

        // Set the camera position
        camera.position.set(0, 6, 0);

        // Set the camera rotation
        camera.rotation.x = THREE.MathUtils.degToRad(-90);
        camera.rotation.y = THREE.MathUtils.degToRad(0);
        camera.rotation.z = THREE.MathUtils.degToRad(0);

        const animate = function () {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
          controls.update();
          updateCameraPositionDisplay(camera);

          // Get the chartContainer size and position
          const chartContainer = document.getElementById("chartContainer");
          const { width, height, left, top } =
            chartContainer.getBoundingClientRect();

          // Update the position of the labels
          cubes.forEach((cube, i) => {
            const labelElement = document.getElementById(`label-${i}`);
            if (labelElement) {
              const vector = new THREE.Vector3();
              vector.setFromMatrixPosition(cube.matrixWorld);
              vector.project(camera);
              // Use the chartContainer size and position to calculate the label positions
              const labelX = (vector.x * 0.5 + 0.5) * width + left;
              const labelY = (vector.y * -0.5 + 0.5) * height + top;
              labelElement.style.left = `${labelX}px`;
              labelElement.style.top = `${labelY}px`;
            }
          });
        };

        createGrid();
        createAxisLabels();
        animate();
      }

      ////////

      function mapXValue(value, min1, max1, min2, max2) {
        // Ensure the value is within the range [min1, max1]
        value = Math.min(Math.max(value, min1), max1);

        // Calculate the mapped value in the range [min2, max2]
        var mappedValue =
          ((value - min1) * (max2 - min2)) / (max1 - min1) + min2;

        return mappedValue;
      }

      function mapYValue(value, min1, max1, min2, max2) {
        // Ensure the value is within the range [min1, max1]
        value = Math.min(Math.max(value, min1), max1);

        // Calculate the mapped value in the inverted range [min2, max2]
        var mappedValue = (max1 - value) / (max1 - min1);

        return mappedValue;
      }
      // Function to load JSON data
      function loadJSONData() {
        // You can adjust the URL to your JSON file
        fetch(
          "https://fiskalloy.com/wp-admin/admin-ajax.php?action=fskdm_alloy_graph_data"
        )
          .then((response) => response.json())
          .then((data) => {
            jsonData = data; // Store the loaded JSON data

            const alloyData = jsonData.filter(
              (item) =>
                item.type.includes("Alloy Wire") ||
                item.type.includes("Alloy Conductors")
            );

            const fineWireData = jsonData
              .filter((item) => item.type.includes("Fine Wire"))
              .map((item) => {
                // Create a new object to avoid mutating the original item
                let newItem = { ...item };
                // Flatten the type array
                newItem.type = [item.type.find((type) => type === "Fine Wire")];
                // Use the second color if it exists, otherwise use the first color
                newItem.color = item.color[1]
                  ? [item.color[1]]
                  : [item.color[0]];
                return newItem;
              });

            createScatterPlot(alloyData.concat(fineWireData));

            // createScatterPlot(alloyData);
          })
          .catch((error) => {
            console.error("Error loading JSON data:", error);
          });
      }

      // document.addEventListener("click", onDocumentMouseClick, false);
      const chartContainer = document.getElementById("chartContainer");

      // Add click event listener to chartContainer
      chartContainer.addEventListener("click", onDocumentMouseClick, false);

      // Get the checkboxes
      const checkboxes = document.querySelectorAll(
        'input[name="dataType"].performance-checkbox'
      );

      // Listen for changes to the checkboxes
      checkboxes.forEach((checkbox) => {
        checkbox.addEventListener("change", () => {
          // Create an object with the visibility for each data type
          const dataTypes = {};
          checkboxes.forEach((checkbox) => {
            dataTypes[checkbox.value] = checkbox.checked;
          });

          // Filter the data
          filterData(dataTypes);
        });
      });

      // drop down
      // Get the dropdown elements
      const minConductivityDropdown =
        document.getElementById("minConductivity");
      const minTensileStrengthDropdown =
        document.getElementById("minTensileStrength");

      // Add event listeners
      minConductivityDropdown.addEventListener("change", filterMyData);
      minTensileStrengthDropdown.addEventListener("change", filterMyData);

      function filterMyData() {
        const minConductivity = Number(minConductivityDropdown.value);
        const minTensileStrength = Number(minTensileStrengthDropdown.value);

        ///
        // Get the checkboxes
        const checkboxes = document.querySelectorAll('input[name="dataType"]');

        // Create an object with the visibility for each data type
        const dataTypes = {};
        checkboxes.forEach((checkbox) => {
          dataTypes[checkbox.value] = checkbox.checked;
        });

        ///

        // Loop through the base cubes
        // Loop through the base cubes
        cubes.forEach((cube) => {
          //console.log(cube.userData.type);
          if (
            cube.userData.type.includes("Alloy Conductors") ||
            cube.userData.type.includes("Alloy Wire") ||
            cube.userData.type.includes("Fine Wire")
          ) {
            //console.log(cube.userData.y_conduct_e, cube.userData.x_tensile_e);

            if (
              cube.userData.y_conduct_e >= minConductivity &&
              cube.userData.x_tensile_e >= minTensileStrength
            ) {
              cube.visible = true;
              cube.userData.labelElement.style.display = "block";
            } else {
              cube.visible = false;
              cube.userData.labelElement.style.display = "none";
            }
          }
        });

        // Loop through the other cubes
        allCubes.forEach((cube) => {
          // Find the base cube that corresponds to this cube
          const baseCubeId = cube.userData.baseCubeId;
          const baseCube = cubes.find((c) => c.userData.id === baseCubeId);

          if (baseCube && baseCube.visible === false) {
            cube.visible = false;
          } else if (dataTypes[cube.userData.type]) {
            cube.visible = true;
          } else {
            cube.visible = false;
          }
        });

        // Add this line to re-render the scene
        //renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
