<!DOCTYPE html>
<html>
  <head>
    <title>3D Scatter Plot</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>
  <body>
    <!-- <div id="uiContainer">
      <div>
        <label>
          <input type="radio" name="dataType" value="all" checked /> All Data
        </label>
      </div>
      <div>
        <label>
          <input type="radio" name="dataType" value="conductor" /> Conductor
        </label>
      </div>
      <div>
        <label>
          <input type="radio" name="dataType" value="alloy" /> Alloy
        </label>
      </div>
      <div>
        <label>
          <input type="radio" name="dataType" value="fire wire" /> Fire Wire
        </label>
      </div>
    </div> -->
    <div id="cameraPosition"></div>
    <div id="chartContainer"></div>
    <div id="info"></div>
    <div id="label"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/controls/OrbitControls.js"></script>

    <script>
      // Declare global variables
      let scene, camera, font;
      const gridSizeX = 16; // Number of columns
      const gridSizeY = 7; // Number of rows
      const cubeSize = 0.4;

      // Load the font using FontLoader at the beginning
      const loader = new THREE.FontLoader();
      loader.load(
        "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
        function (loadedFont) {
          font = loadedFont; // Store the loaded font
          // Continue with loading JSON data
          loadJSONData();
        }
      );

      // Function to filter data based on the selected radio button
      function filterData(dataType) {
        scene.children.forEach((child) => {
          if (child.userData && child.userData.type) {
            if (dataType === "all" || child.userData.type === dataType) {
              child.visible = true;
            } else {
              child.visible = false;
            }
          }
        });
      }

      // Function to create a single cube
      function createCube(x, y, z, size, color, type) {
        const geometry = new THREE.BoxGeometry(size, size, size);
        const material = new THREE.MeshPhongMaterial({ color });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y + size / 2, z);
        // Add metadata indicating the type of data (e.g., "conductor", "alloy", "fire wire")
        cube.userData.type = type;
        return cube;
      }
      function createCubeHalf(x, y, z, size, color, type) {
        const geometry = new THREE.BoxGeometry(size, size / 2, size);
        const material = new THREE.MeshPhongMaterial({ color });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y + size / 2, z);
        // Add metadata indicating the type of data (e.g., "conductor", "alloy", "fire wire")
        cube.userData.type = type;
        return cube;
      }

      // Function to create the grid
      function createGrid() {
        const gridTexture = new THREE.TextureLoader().load(
          "https://threejs.org/examples/textures/grid.png"
        );
        gridTexture.wrapS = THREE.RepeatWrapping;
        gridTexture.wrapT = THREE.RepeatWrapping;

        // Adjust the repeat values for rows and columns
        gridTexture.repeat.set(gridSizeX - 1, gridSizeY - 1);

        const floorGeometry = new THREE.PlaneGeometry(
          gridSizeX,
          gridSizeY,
          gridSizeX - 1,
          gridSizeY - 1
        );
        const floorMaterial = new THREE.MeshPhongMaterial({
          map: gridTexture,
          wireframe: true, // Display as wireframe
          color: 0xffffff, // Set the floor color to grey
        });
        const yPosition = 0;
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, yPosition, 0);
        scene.add(floor);
      }

      // Function to display camera position
      function updateCameraPositionDisplay(camera) {
        const cameraPositionElement = document.getElementById("cameraPosition");
        const position = camera.position;
        const rotation = camera.rotation;

        // Round the values for display
        const posX = position.x.toFixed(2);
        const posY = position.y.toFixed(2);
        const posZ = position.z.toFixed(2);
        const rotX = THREE.MathUtils.radToDeg(rotation.x).toFixed(2);
        const rotY = THREE.MathUtils.radToDeg(rotation.y).toFixed(2);
        const rotZ = THREE.MathUtils.radToDeg(rotation.z).toFixed(2);

        // Update the HTML element
        cameraPositionElement.innerHTML = `
                      Camera Position:<br>
                      X: ${posX}, Y: ${posY}, Z: ${posZ}<br>
                      Rotation X: ${rotX}, Y: ${rotY}, Z: ${rotZ}
                    `;
      }

      function createYAxisLabels(yAxisValues) {
        for (let i = 0; i < yAxisValues.length; i++) {
          let yPoint = yAxisValues[i];
          var xValueToMap = yPoint.x; // This value is in the range [0, 140]
          var mappedXValue = mapXValue(xValueToMap, 0, 150, 0, 1);
          var yValueToMap = yPoint.y; // This value is in the range [0, 120]
          var mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0; // You can adjust the vertical position if needed
          const z = (mappedYValue - 0.5) * gridSizeY;

          const labelGeometry = new THREE.TextGeometry(yPoint.label, {
            font: font,
            size: 0.2, // Adjust the size as needed
            height: 0.01, // Adjust the height as needed
          });

          const labelMaterial = new THREE.MeshBasicMaterial({
            color: 0x999999,
          });

          const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);

          // Rotate the label to be vertical
          labelMesh.rotation.x = -Math.PI / 2;

          const labelX = gridSizeX / 2 - cubeSize / 2 + 1.1; // Adjust the X position to right-align the text
          const labelY = 0;
          const labelZ = z;

          labelMesh.position.set(-8.75, labelY, labelZ);

          scene.add(labelMesh);
        }
      }

      function createXAxisLabels(xAxisValues) {
        for (let i = 0; i < xAxisValues.length; i++) {
          let xPoint = xAxisValues[i];
          var xValueToMap = xPoint.x - 1.5; // This value is in the range [0, 150]
          var mappedXValue = mapXValue(xValueToMap, 0, 150, 0, 1);
          var yValueToMap = xPoint.y; // This value is in the range [0, 120]
          var mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0; // You can adjust the vertical position if needed
          const z = (mappedYValue - 0.5) * gridSizeY;

          const labelGeometry = new THREE.TextGeometry(xPoint.label, {
            font: font,
            size: 0.2, // Adjust the size as needed
            height: 0.01, // Adjust the height as needed
          });

          const labelMaterial = new THREE.MeshBasicMaterial({
            color: 0x999999,
          });

          const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);

          // Rotate the label to be vertical
          labelMesh.rotation.x = -Math.PI / 2;

          const labelX = x;
          const labelY = 0;
          const labelZ = gridSizeY / 2 - cubeSize / 2 + 0.5; // Adjust the Z position to align with the bottom

          labelMesh.position.set(labelX, labelY, labelZ);

          scene.add(labelMesh);
        }
      }

      // Add the raycasting and click event handling code here
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      // Inside your animation loop, check for raycasting and mouse events
      const onDocumentMouseClick = (event) => {
        console.log("we have clicked");
        event.preventDefault();

        // Calculate the mouse position in normalized device coordinates
        // (-1 to 1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Check for intersections with clickable objects (e.g., cubes)
        const intersects = raycaster.intersectObjects(scene.children, true);
        console.log(intersects.length, "intersects");

        if (intersects.length > 0) {
          // Handle the click event for the clicked cube
          const clickedObject = intersects[0].object;
          console.log(clickedObject);

          if (clickedObject.userData.url) {
            window.open(clickedObject.userData.url, "_blank");
          }
        }
      };

      // Add an event listener for 'mousemove'
      // window.addEventListener(
      //   "mousemove",
      //   (event) => {
      //     event.preventDefault();

      //     // Calculate the mouse position in normalized device coordinates
      //     // (-1 to 1) for both components
      //     mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      //     mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      //     raycaster.setFromCamera(mouse, camera);

      //     // Check for intersections with clickable objects (e.g., cubes)
      //     const intersects = raycaster.intersectObjects(scene.children, true);
      //     let labelElement = document.getElementById("label");
      //     if (intersects.length > 0) {
      //       const hoveredObject = intersects[0].object;

      //       // Access the type
      //       let type = hoveredObject.userData.type;

      //       if (type) {
      //         // Update the label element with the type
      //         //labelElement.textContent = type;
      //         labelElement.innerHTML = `${type}<br>Information 1<br>Information 2`;

      //         // Calculate the 2D position of the cube
      //         const vector = new THREE.Vector3();
      //         vector.setFromMatrixPosition(hoveredObject.matrixWorld);
      //         vector.project(camera);

      //         // Convert the normalized position to CSS coordinates
      //         const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
      //         const y = (vector.y * -0.5 + 0.5) * window.innerHeight;

      //         // Update the label position
      //         labelElement.style.left = `${x}px`;
      //         labelElement.style.top = `${y}px`;

      //         // Make the label visible
      //         labelElement.style.display = "block";
      //       } else {
      //         // If type is null or an empty string, hide the label
      //         labelElement.style.display = "none";
      //       }
      //     } else {
      //       // If there are no intersections, hide the label
      //       labelElement.style.display = "none";
      //     }
      //   },
      //   false
      // );

      function getColor(productType) {
        switch (productType) {
          case "Alloy Conductor Soft Temper":
            return "#aa934d";
          case "Alloy Conductor Hard Temper":
            return "#7d4daa"; // Replace with the actual color you choose
          case "Alloy Wire":
            return "#123152";
          case "Fine Wire":
            return "#43837d";
          default:
            return "#000000";
        }
      }

      function getColorBasedOnFactors(dataPoint) {
        // Define default colors for each type
        const defaultColors = {
          "Alloy Conductor Soft Temper": "#aa934d",
          "Alloy Conductor Hard Temper": "#867bcc",
          "Alloy Wire": "#123152",
          "Fine Wire": "#43837d",
          // Add more types and default colors as needed
        };

        // Define colors for each factor
        const factorColors = {
          stress_relaxation: "#bece71", // Flex Life
          spring_properties: "#6cb2c4", // Spring Properties
          formability: "#cfc250", // Formability
          // Add more factors and colors as needed
        };

        // Choose the default color based on the product type
        let color = defaultColors[dataPoint.type[0]] || "#FFFFFF"; // Default to white if type is not recognized

        // Apply colors based on factors
        if (dataPoint.stress_relaxation) {
          color = factorColors.stress_relaxation;
        }
        if (dataPoint.spring_properties) {
          color = factorColors.spring_properties;
        }
        if (dataPoint.formability) {
          color = factorColors.formability;
        }

        return color;
      }

      function createLabel(cube, i, labelContent) {
        // Create a label for the cube
        let labelElement = document.createElement("div");
        labelElement.id = `label-${i}`;
        labelElement.style.position = "absolute";
        labelElement.style.backgroundColor = "#d5d5d5";
        // labelElement.style.padding = "10px";
        labelElement.className = "cube-label";
        // Set the label text

        // Append the label to the body
        let contentWrapper = document.createElement("div");
        contentWrapper.textContent = labelContent;
        labelElement.appendChild(contentWrapper);

        // Position the label at the base of the cube
        // This will depend on how your cubes are positioned and might require adjusting
        const vector = new THREE.Vector3();
        vector.setFromMatrixPosition(cube.matrixWorld);
        vector.project(camera);
        const labelX = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const labelY = (vector.y * -0.5 + 0.5) * window.innerHeight;
        labelElement.style.left = `${labelX}px`;
        labelElement.style.top = `${labelY}px`;
        // labelElement.style.height = "15px";
        // Store the original size

        // Add event listeners
        // Add event listeners
        labelElement.addEventListener("mouseover", function () {
          // Increase size and change content on mouseover
          labelElement.style.width = "200px"; // Replace with the new width
          labelElement.style.height = "100px"; // Replace with the new height
          contentWrapper.innerHTML =
            "Material Name<br>Click to view specifications";
        });

        labelElement.addEventListener("mouseout", function () {
          // Reset size and content on mouseout
          labelElement.style.width = "auto";
          labelElement.style.height = "auto";
          contentWrapper.textContent = labelContent;
        });

        labelElement.addEventListener("click", function () {
          // Navigate to product page
          window.location.href = "https://fiskalloy.com/";
        });
        document.body.appendChild(labelElement);
      }
      // Define an array to store your cubes
      let cubes = [];
      function createScatterPlot() {
        scene = new THREE.Scene();
        scene.scale.set(0.5, 0.5, 0.5); // Adjust the scale as needed
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        document
          .getElementById("chartContainer")
          .appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        for (let i = 0; i < jsonData.data.entries.length; i++) {
          const dataPoint = jsonData.data.entries[i];
          const xValueToMap = dataPoint.x_tensile_e;
          const mappedXValue = mapXValue(xValueToMap, 0, 150, 0, 1);

          const yValueToMap = dataPoint.y_conduct_e;
          const mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0;

          const z = (mappedYValue - 0.5) * gridSizeY;

          let numCubes;
          let color = getColorBasedOnFactors(dataPoint);

          switch (dataPoint.product_name) {
            case "C11000 ETP":
              numCubes = 7;
              // Create BASE box
              const baseCube = createCubeHalf(
                x,
                y,
                z,
                cubeSize,
                "#123152", //
                dataPoint.type[0]
              );
              baseCube.userData.url = dataPoint.product_url;
              scene.add(baseCube);
              cubes.push(baseCube);
              createLabel(baseCube, i, "C11000 ETP");

              // Create stack with 1 box alloy wire bright lime green/stress relaxation
              for (let j = 1; j <= 1; j++) {
                const alloyWireCube = createCube(
                  x,
                  y + j * cubeSize - 0.1,
                  z,
                  cubeSize,
                  "#bece71", // Bright lime green
                  "Alloy Wire"
                );
                alloyWireCube.userData.url = dataPoint.product_url;
                scene.add(alloyWireCube);
              }

              // Create stack with 1 box of turquoise Spring properties
              for (let j = 2; j <= 2; j++) {
                const turquoiseCube = createCube(
                  x,
                  y + j * cubeSize - 0.1,
                  z,
                  cubeSize,
                  "#6cb2b4", // Turquoise
                  "Turquoise"
                );
                turquoiseCube.userData.url = dataPoint.product_url;
                scene.add(turquoiseCube);
              }

              // Create stack with 5 boxes of mustard formability
              for (let j = 3; j <= 7; j++) {
                const mustardCube = createCube(
                  x,
                  y + j * cubeSize - 0.1,
                  z,
                  cubeSize,
                  "#cfc250", // Mustard
                  "Mustard"
                );
                mustardCube.userData.url = dataPoint.product_url;
                scene.add(mustardCube);
              }
              break;
            case "C75200":
              numCubes = 11;

              // Create BASE box
              const baseCubeC75200 = createCubeHalf(
                x,
                y,
                z,
                cubeSize,
                "#123152",
                dataPoint.type[0]
              );
              baseCubeC75200.userData.url = dataPoint.product_url;
              scene.add(baseCubeC75200);
              cubes.push(baseCubeC75200);
              createLabel(baseCubeC75200, i, "C75200");

              // Create stack with 4 boxes of Lime/stress relaxation
              for (let j = 1; j <= 4; j++) {
                const limeCube = createCube(
                  x,
                  y + j * cubeSize - 0.1,
                  z,
                  cubeSize,
                  "#bece71", // Lime green
                  "Lime"
                );
                limeCube.userData.url = dataPoint.product_url;
                scene.add(limeCube);
              }

              // Create stack with 4 boxes of turquoise Spring properties
              for (let j = 5; j <= 8; j++) {
                const turquoiseCube = createCube(
                  x,
                  y + j * cubeSize - 0.1,
                  z,
                  cubeSize,
                  "#6cb2b4", // Turquoise
                  "Turquoise"
                );
                turquoiseCube.userData.url = dataPoint.product_url;
                scene.add(turquoiseCube);
              }

              // Create stack with 3 boxes of mustard formability
              for (let j = 9; j <= 11; j++) {
                const mustardCube = createCube(
                  x,
                  y + j * cubeSize - 0.1,
                  z,
                  cubeSize,
                  "#cfc250", // Mustard
                  "Mustard"
                );
                mustardCube.userData.url = dataPoint.product_url;
                scene.add(mustardCube);
              }
              break;
            case "C17200":
              numCubes = 13;
              // Create BASE box in deeper green
              const baseCubeC17200 = createCubeHalf(
                x,
                y,
                z,
                cubeSize,
                "#43837d", // Deeper green
                dataPoint.type[0]
              );
              baseCubeC17200.userData.url = dataPoint.product_url;
              scene.add(baseCubeC17200);
              cubes.push(baseCubeC17200);
              createLabel(baseCubeC17200, i, "C17200");

              // Create stack with 4 boxes of lime
              for (let j = 1; j <= 4; j++) {
                const limeCube = createCube(
                  x,
                  y + j * cubeSize - 0.1,
                  z,
                  cubeSize,
                  "#bece71", // Lime
                  "Lime"
                );
                limeCube.userData.url = dataPoint.product_url;
                scene.add(limeCube);
              }

              // Create stack with 5 boxes of turquoise
              for (let j = 5; j <= 9; j++) {
                const turquoiseCube = createCube(
                  x,
                  y + j * cubeSize - 0.1,
                  z,
                  cubeSize,
                  "#6cb2b4", // Turquoise
                  "Turquoise"
                );
                turquoiseCube.userData.url = dataPoint.product_url;
                scene.add(turquoiseCube);
              }

              // Create stack with 4 boxes of mustard
              for (let j = 10; j <= 13; j++) {
                const mustardCube = createCube(
                  x,
                  y + j * cubeSize - 0.1,
                  z,
                  cubeSize,
                  "#cfc250", // Mustard
                  "Mustard"
                );
                mustardCube.userData.url = dataPoint.product_url;
                scene.add(mustardCube);
              }
              break;
          }
        }

        // Define your yAxisValues using a loop
        let yAxisValues = [];
        for (let y = 100; y >= 0; y -= 20) {
          yAxisValues.push({
            x: 0,
            y,
            z: -3.3333333333333335,
            label: y.toString(),
          });
        }

        // Call the createYAxisLabels method
        createYAxisLabels(yAxisValues);

        // Define an array to store X-axis values
        const xAxisValues = [];

        // Create X-axis labels from 0 to 140 with a step of 10
        for (let x = 0; x <= 140; x += 10) {
          xAxisValues.push({ x, y: 0, label: x.toString() });
        }
        // Call the function to create X-axis labels
        createXAxisLabels(xAxisValues);

        // Lights
        const light1 = new THREE.DirectionalLight(0xffffff, 1);
        light1.position.set(1, 1, 1);
        scene.add(light1);

        const light2 = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(light2);

        camera.position.set(-3, 2, 5);

        const animate = function () {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
          controls.update();
          updateCameraPositionDisplay(camera);

          ////

          // Update the position of the labels
          cubes.forEach((cube, i) => {
            const labelElement = document.getElementById(`label-${i}`);
            if (labelElement) {
              const vector = new THREE.Vector3();
              vector.setFromMatrixPosition(cube.matrixWorld);
              vector.project(camera);
              const labelX = (vector.x * 0.5 + 0.5) * window.innerWidth;
              const labelY = (vector.y * -0.5 + 0.5) * window.innerHeight;
              labelElement.style.left = `${labelX}px`;
              labelElement.style.top = `${labelY}px`;
            }
          });
        };

        createGrid();
        animate();
      }

      ////////

      function getRandomColor() {
        const letters = "0123456789ABCDEF";
        let color = "#";
        for (let i = 0; i < 6; i++) {
          color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
      }

      function mapXValue(value, min1, max1, min2, max2) {
        // Ensure the value is within the range [min1, max1]
        value = Math.min(Math.max(value, min1), max1);

        // Calculate the mapped value in the range [min2, max2]
        var mappedValue =
          ((value - min1) * (max2 - min2)) / (max1 - min1) + min2;

        return mappedValue;
      }

      function mapYValue(value, min1, max1, min2, max2) {
        // Ensure the value is within the range [min1, max1]
        value = Math.min(Math.max(value, min1), max1);

        // Calculate the mapped value in the inverted range [min2, max2]
        var mappedValue = (max1 - value) / (max1 - min1);

        return mappedValue;
      }
      // Function to load JSON data
      function loadJSONData() {
        // You can adjust the URL to your JSON file
        fetch("data_poc.json")
          .then((response) => response.json())
          .then((data) => {
            jsonData = data; // Store the loaded JSON data

            // Continue with creating the scatter plot
            createScatterPlot();
          })
          .catch((error) => {
            console.error("Error loading JSON data:", error);
          });
      }

      document.addEventListener("click", onDocumentMouseClick, false);

      // Add event listener to radio buttons
      const radioButtons = document.querySelectorAll('input[name="dataType"]');

      radioButtons.forEach((radioButton) => {
        radioButton.addEventListener("change", (event) => {
          const selectedDataType = event.target.value;
          filterData(selectedDataType);
        });
      });
    </script>
  </body>
</html>
