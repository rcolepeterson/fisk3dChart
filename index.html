<!DOCTYPE html>
<!-- https://fiskalloy.com/products/alloy-explorer/ -->
<!-- https://github.com/rcolepeterson/testmechart/blob/labels/index.html#L140 -->
<html>
  <head>
    <title>3D Scatter Plot</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
  </head>
  <body>
    <div id="cameraPosition"></div>
    <div id="chartContainer"></div>
    <div id="info"></div>
    <div id="label"></div>
    <div id="dd">
      <!-- Add these dropdowns in your HTML -->
      <div class="form-group">
        <label for="minConductivity">Minimum Conductivity</label>
        <select id="minConductivity" class="minimal">
          <!-- Add options from 0 to 100 in increments of 10 -->
          <option value="0">0</option>
          <option value="10">10</option>
          <option value="20">20</option>
          <option value="30">30</option>
          <option value="40">40</option>
          <option value="50">50</option>
          <option value="60">60</option>
          <option value="70">70</option>
          <option value="80">80</option>
          <option value="90">90</option>
          <option value="100">100</option>
          <!-- Add more options as needed -->
        </select>
      </div>

      <div class="form-group">
        <label for="minTensileStrength">Minimum Tensile Strength</label>
        <select id="minTensileStrength" class="minimal">
        <!-- Add options from 0 to 200 in increments of 10 -->
        <option value="0">0</option>
        <option value="10">10</option>
        <option value="20">20</option>
        <option value="30">30</option>
        <option value="40">40</option>
        <option value="50">50</option>
        <option value="60">60</option>
        <option value="70">70</option>
        <option value="80">80</option>
        <option value="90">90</option>
        <option value="100">100</option>
        <option value="110">110</option>
        <option value="120">120</option>
        <option value="130">130</option>
        <option value="140">140</option>
        <option value="150">150</option>
        <option value="160">160</option>
        <option value="170">170</option>
        <option value="180">180</option>
        <option value="190">190</option>
        <option value="200">200</option>
        <!-- Add more options as needed -->
      </select>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.130.1/examples/js/controls/OrbitControls.js"></script>

    <script>
      // Declare global variables
      let scene, camera, font;
      const gridSizeX = 16; // Number of columns
      const gridSizeY = 7; // Number of rows
      const cubeSize = 0.4;

      // Load the font using FontLoader at the beginning
      const loader = new THREE.FontLoader();
      loader.load(
        "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
        function (loadedFont) {
          font = loadedFont;
          // Continue with loading JSON data
          loadJSONData();
        }
      );

      // Function to display camera position
      function updateCameraPositionDisplay(camera) {
        const cameraPositionElement = document.getElementById("cameraPosition");
        const position = camera.position;
        const rotation = camera.rotation;

        // Round the values for display
        const posX = position.x.toFixed(2);
        const posY = position.y.toFixed(2);
        const posZ = position.z.toFixed(2);
        const rotX = THREE.MathUtils.radToDeg(rotation.x).toFixed(2);
        const rotY = THREE.MathUtils.radToDeg(rotation.y).toFixed(2);
        const rotZ = THREE.MathUtils.radToDeg(rotation.z).toFixed(2);

        // Update the HTML element
        cameraPositionElement.innerHTML = `
          Camera Position:<br>
          X: ${posX}, Y: ${posY}, Z: ${posZ}<br>
          Rotation X: ${rotX}, Y: ${rotY}, Z: ${rotZ}
        `;
      }

      // Function to filter data based on the selected radio button
      function filterData(dataType) {
        scene.children.forEach((child) => {
          if (child.userData && child.userData.type) {
            if (dataType === "all" || child.userData.type === dataType) {
              child.visible = true;
            } else {
              child.visible = false;
            }
          }
        });
      }

      // Function to create a single cube
      function createCube(x, y, z, size, color, type) {
        const geometry = new THREE.BoxGeometry(size, size, size);
        const material = new THREE.MeshPhongMaterial({ color });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y + size / 2, z);
        // Add metadata indicating the type of data (e.g., "conductor", "alloy", "fire wire")
        cube.userData.type = type;
        return cube;
      }
      function createCubeHalf(x, y, z, size, color, type) {
        const geometry = new THREE.BoxGeometry(size, size / 2, size);
        const material = new THREE.MeshPhongMaterial({ color });
        const cube = new THREE.Mesh(geometry, material);
        cube.position.set(x, y + size / 2, z);
        // Add metadata indicating the type of data (e.g., "conductor", "alloy", "fire wire")
        cube.userData.type = type;
        return cube;
      }

      // Function to create the grid
      function createGrid() {
        const gridTexture = new THREE.TextureLoader().load(
          "https://threejs.org/examples/textures/grid.png"
        );
        gridTexture.wrapS = THREE.RepeatWrapping;
        gridTexture.wrapT = THREE.RepeatWrapping;

        // Adjust the repeat values for rows and columns
        gridTexture.repeat.set(gridSizeX - 1, gridSizeY - 1);

        const floorGeometry = new THREE.PlaneGeometry(
          gridSizeX,
          gridSizeY,
          gridSizeX - 1,
          gridSizeY - 1
        );
        const floorMaterial = new THREE.MeshPhongMaterial({
          map: gridTexture,
          wireframe: true, // Display as wireframe
          color: 0xffffff, // Set the floor color to grey
        });
        const yPosition = 0;
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(0, yPosition, 0);
        scene.add(floor);
      }

      // Function to display camera position
      function updateCameraPositionDisplay(camera) {
        const cameraPositionElement = document.getElementById("cameraPosition");
        const position = camera.position;
        const rotation = camera.rotation;

        // Round the values for display
        const posX = position.x.toFixed(2);
        const posY = position.y.toFixed(2);
        const posZ = position.z.toFixed(2);
        const rotX = THREE.MathUtils.radToDeg(rotation.x).toFixed(2);
        const rotY = THREE.MathUtils.radToDeg(rotation.y).toFixed(2);
        const rotZ = THREE.MathUtils.radToDeg(rotation.z).toFixed(2);

        // Update the HTML element
        cameraPositionElement.innerHTML = `
                      Camera Position:<br>
                      X: ${posX}, Y: ${posY}, Z: ${posZ}<br>
                      Rotation X: ${rotX}, Y: ${rotY}, Z: ${rotZ}
                    `;
      }

      function createYAxisLabels(yAxisValues) {
        for (let i = 0; i < yAxisValues.length; i++) {
          let yPoint = yAxisValues[i];
          var xValueToMap = yPoint.x; // This value is in the range [0, 140]
          var mappedXValue = mapXValue(xValueToMap, 0, 150, 0, 1);
          var yValueToMap = yPoint.y - 1.5; // This value is in the range [0, 120]
          var mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0; // You can adjust the vertical position if needed
          const z = (mappedYValue - 0.5) * gridSizeY;

          const labelGeometry = new THREE.TextGeometry(yPoint.label, {
            font: font,
            size: 0.2, // Adjust the size as needed
            height: 0.01, // Adjust the height as needed
          });

          const labelMaterial = new THREE.MeshBasicMaterial({
            color: 0x999999,
          });

          const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);

          // Rotate the label to be vertical
          labelMesh.rotation.x = -Math.PI / 2;

          const labelX = gridSizeX / 2 - cubeSize / 2 + 1.1; // Adjust the X position to right-align the text
          const labelY = 0;
          const labelZ = z;

          labelMesh.position.set(-8.75, labelY, labelZ);

          scene.add(labelMesh);
        }
      }

      function createXAxisLabels(xAxisValues) {
        for (let i = 0; i < xAxisValues.length; i++) {
          let xPoint = xAxisValues[i];
          var xValueToMap = xPoint.x - 1.5; // This value is in the range [0, 150]
          var mappedXValue = mapXValue(xValueToMap, 0, 150, 0, 1);
          var yValueToMap = xPoint.y; // This value is in the range [0, 120]
          var mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0; // You can adjust the vertical position if needed
          const z = (mappedYValue - 0.5) * gridSizeY;

          const labelGeometry = new THREE.TextGeometry(xPoint.label, {
            font: font,
            size: 0.2, // Adjust the size as needed
            height: 0.01, // Adjust the height as needed
          });

          const labelMaterial = new THREE.MeshBasicMaterial({
            color: 0x999999,
          });

          const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);

          // Rotate the label to be vertical
          labelMesh.rotation.x = -Math.PI / 2;

          const labelX = x;
          const labelY = 0;
          const labelZ = gridSizeY / 2 - cubeSize / 2 + 0.5; // Adjust the Z position to align with the bottom

          labelMesh.position.set(labelX, labelY, labelZ);

          scene.add(labelMesh);
        }
      }

      function createAxisLabels() {
  const xAxisLabelGeometry = new THREE.TextGeometry('TENSILE STRENGTH (ksi)', {
    font: font,
    size: 0.3, // Adjust the size as needed
    height: 0.01, // Adjust the height as needed
  });

  const yAxisLabelGeometry = new THREE.TextGeometry('CONDUCTIVITY (% IACS @ 68°F)', {
    font: font,
    size: 0.3, // Adjust the size as needed
    height: 0.01, // Adjust the height as needed
  });

  const labelMaterial = new THREE.MeshBasicMaterial({
    color: 0x999999,
  });

  const xAxisLabelMesh = new THREE.Mesh(xAxisLabelGeometry, labelMaterial);
  const yAxisLabelMesh = new THREE.Mesh(yAxisLabelGeometry, labelMaterial);

  // Rotate the labels to be vertical
  xAxisLabelMesh.rotation.x = -Math.PI / 2;
  //yAxisLabelMesh.rotation.x = -Math.PI / 2;

  // Rotate the Y-axis label to align with the Y-axis
yAxisLabelMesh.rotation.x = -Math.PI / 2;
yAxisLabelMesh.rotation.z = Math.PI/2; // Rotate around the Z-axis


  // Position the labels at the midpoint of the respective axes
  // xAxisLabelMesh.position.set(0, gridSizeY / 2, gridSizeY / 2 - cubeSize / 2 + 0.5);
  // Position the labels at the midpoint of the respective axes
const labelX = -2; // Midpoint of the X-axis
const labelY = 0;
const labelZ = 4.6; // Same Z position as the grid labels

xAxisLabelMesh.position.set(labelX, labelY, labelZ);
const yAxisLabelX = -gridSizeX / 2 - 1.2; // Left side of the X-axis
const yAxisLabelY = 0;
const yAxisLabelZ = 3; // Same Z position as the grid labels
//console.log(gridSizeY / 2 - cubeSize / 2 + 0.5 );
yAxisLabelMesh.position.set(yAxisLabelX, yAxisLabelY, yAxisLabelZ);


  scene.add(xAxisLabelMesh);
  scene.add(yAxisLabelMesh);
}

      // Add the raycasting and click event handling code here
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();

      // Inside your animation loop, check for raycasting and mouse events
      const onDocumentMouseClick = (event) => {
        //console.log("we have clicked");
        event.preventDefault();

        // Calculate the mouse position in normalized device coordinates
        // (-1 to 1) for both components
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Check for intersections with clickable objects (e.g., cubes)
        const intersects = raycaster.intersectObjects(scene.children, true);
        // console.log(intersects.length, "intersects");

        if (intersects.length > 0) {
          // Handle the click event for the clicked cube
          const clickedObject = intersects[0].object;
          //  console.log(clickedObject);

          if (clickedObject.userData.url) {
            window.open(clickedObject.userData.url, "_blank");
          }
        }
      };

      function createLabel(cube, i, labelContent) {
        // Create a label for the cube
        let labelElement = document.createElement("div");
        labelElement.id = `label-${i}`;
        labelElement.style.position = "absolute";
        labelElement.style.backgroundColor = "#d5d5d5";
        labelElement.className = "cube-label";
        cube.userData.labelElement = labelElement;

        // Create a wrapper for the normal state
        let normalContent = document.createElement("div");
        normalContent.className = "initial-content";
        normalContent.innerHTML = labelContent.product_shortname;
        let tensileValue = labelContent.x_tensile_e; // replace with actual value
        let conductivityValue = labelContent.y_conduct_e; // replace with actual value

        labelElement.appendChild(normalContent);

        let content = `<div class='content'>${labelContent.product_name}</div>
                    <div class='content'><span class='font-base'>Tensile: </span> ${tensileValue} ksi</div>
                    <div class='content'><span class='font-base'>Conductivity: </span>${conductivityValue} % IACS @ 68°F</div>
                    <div class='content click'>CLICK FOR MORE</div>`;

        // Create a wrapper for the hover state
        let hoverContent = document.createElement("div");
        hoverContent.innerHTML = content;
        hoverContent.style.display = "none"; // Hide it initially
        labelElement.appendChild(hoverContent);

        // Position the label at the base of the cube
        // This will depend on how your cubes are positioned and might require adjusting
        const vector = new THREE.Vector3();
        vector.setFromMatrixPosition(cube.matrixWorld);
        vector.project(camera);
        const labelX = (vector.x * 0.5 + 0.5) * window.innerWidth;
        const labelY = (vector.y * -0.5 + 0.5) * window.innerHeight;
        labelElement.style.left = `${labelX}px`;
        labelElement.style.top = `${labelY}px`;

        labelElement.addEventListener("mouseover", function () {
          // Show hover state and hide normal state
          normalContent.style.display = "none";
          hoverContent.style.display = "block";
        });

        labelElement.addEventListener("mouseout", function () {
          // Show normal state and hide hover state
          normalContent.style.display = "block";
          hoverContent.style.display = "none";
        });

        labelElement.addEventListener("click", function () {
          // Navigate to product page
          window.location.href = "https://fiskalloy.com/";
        });

        document.body.appendChild(labelElement);
      }

      // Define an array to store your cubes
      let cubes = [];
      let allCubes = [];
      function createScatterPlot(data) {
        scene = new THREE.Scene();
        scene.scale.set(0.5, 0.5, 0.5); // Adjust the scale as needed
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0xffffff);
        document
          .getElementById("chartContainer")
          .appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);

        data.forEach((dataPoint, i) => {
          const xValueToMap = dataPoint.x_tensile_e;
          const mappedXValue = mapXValue(xValueToMap, 0, 150, 0, 1);

          const yValueToMap = dataPoint.y_conduct_e;
          const mappedYValue = mapYValue(yValueToMap, 0, 120, 0, 1);

          const x = (mappedXValue - 0.5) * gridSizeX;
          const y = 0;
          const z = (mappedYValue - 0.5) * gridSizeY;
          const properties = [
            "flex_life",
            "soft_resistance",
            "stress_relaxation",
            "spring_properties",
            "machinability",
            "formability",
          ];
          const colors = [
            "#bece71",
            "#6cb2b4",
            "#cfc250",
            "#43837d",
            "#123152",
            "#af933f",
          ];

          // Create base cube
          const baseCube = createCubeHalf(
            x,
            y,
            z,
            cubeSize,
            dataPoint.color[0],
            dataPoint.type[0]
          );
          baseCube.userData.url = dataPoint.product_url;
          baseCube.userData.y_conduct_e = dataPoint.y_conduct_e; // Add this line
          baseCube.userData.x_tensile_e = dataPoint.x_tensile_e;
          baseCube.userData.id = i;
          scene.add(baseCube);
          cubes.push(baseCube);
          createLabel(baseCube, i, dataPoint);

          // Create stacks based on properties
          let cubeY = y;
          properties.forEach((property, index) => {
            const numCubes = dataPoint[property];
            for (let j = 1; j <= numCubes; j++) {
              const cube = createCube(
                x,
                cubeY + j * cubeSize - 0.1,
                z,
                cubeSize,
                colors[index],
                property
              );
              cube.userData.url = dataPoint.product_url;
              cube.userData.y_conduct_e = dataPoint.y_conduct_e; // Add this line
              cube.userData.x_tensile_e = dataPoint.x_tensile_e;
              cube.userData.baseCubeId = i;
              allCubes.push(cube);
              scene.add(cube);
            }
            cubeY += numCubes * cubeSize;
          });
        });

        // Define your yAxisValues using a loop
        let yAxisValues = [];
        for (let y = 100; y >= 0; y -= 20) {
          yAxisValues.push({
            x: 0,
            y,
            z: -3.3333333333333335,
            label: y.toString(),
          });
        }

        // Call the createYAxisLabels method
        createYAxisLabels(yAxisValues);

        // Define an array to store X-axis values
        const xAxisValues = [];

        // Create X-axis labels from 0 to 140 with a step of 10
        for (let x = 0; x <= 140; x += 10) {
          xAxisValues.push({ x, y: 0, label: x.toString() });
        }
        // Call the function to create X-axis labels
        createXAxisLabels(xAxisValues);

        // Lights
        const light1 = new THREE.DirectionalLight(0xffffff, 1);
        light1.position.set(1, 1, 1);
        scene.add(light1);

        const light2 = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(light2);

        // camera.position.set(-3, 2, 5);
        // Set the camera position
        camera.position.set(0, 6, 0);

// Set the camera rotation
        camera.rotation.x = THREE.MathUtils.degToRad(-90);
        camera.rotation.y = THREE.MathUtils.degToRad(0);
        camera.rotation.z = THREE.MathUtils.degToRad(0);

        const animate = function () {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
          controls.update();
          updateCameraPositionDisplay(camera);

          ////

          // Update the position of the labels
          cubes.forEach((cube, i) => {
            const labelElement = document.getElementById(`label-${i}`);
            if (labelElement) {
              const vector = new THREE.Vector3();
              vector.setFromMatrixPosition(cube.matrixWorld);
              vector.project(camera);
              const labelX = (vector.x * 0.5 + 0.5) * window.innerWidth;
              const labelY = (vector.y * -0.5 + 0.5) * window.innerHeight;
              labelElement.style.left = `${labelX}px`;
              labelElement.style.top = `${labelY}px`;
            }
          });
        };

        createGrid();
        createAxisLabels();
        animate();
      }

      ////////

     

      function mapXValue(value, min1, max1, min2, max2) {
        // Ensure the value is within the range [min1, max1]
        value = Math.min(Math.max(value, min1), max1);

        // Calculate the mapped value in the range [min2, max2]
        var mappedValue =
          ((value - min1) * (max2 - min2)) / (max1 - min1) + min2;

        return mappedValue;
      }

      function mapYValue(value, min1, max1, min2, max2) {
        // Ensure the value is within the range [min1, max1]
        value = Math.min(Math.max(value, min1), max1);

        // Calculate the mapped value in the inverted range [min2, max2]
        var mappedValue = (max1 - value) / (max1 - min1);

        return mappedValue;
      }
      // Function to load JSON data
      function loadJSONData() {
        // You can adjust the URL to your JSON file
        fetch("alloy.json")
          .then((response) => response.json())
          .then((data) => {
            jsonData = data; // Store the loaded JSON data

            // Continue with creating the scatter plot
            //createScatterPlot(data);
            // const firstItem = [data[0]];
            // createScatterPlot(firstItem);
            const alloyConductors = jsonData.filter((item) =>
              item.type.includes("Alloy Conductors")
            );
            createScatterPlot(alloyConductors);
          })
          .catch((error) => {
            console.error("Error loading JSON data:", error);
          });
      }

      document.addEventListener("click", onDocumentMouseClick, false);

      // Add event listener to radio buttons
      const radioButtons = document.querySelectorAll('input[name="dataType"]');

      radioButtons.forEach((radioButton) => {
        radioButton.addEventListener("change", (event) => {
          const selectedDataType = event.target.value;
          filterData(selectedDataType);
        });
      });

      // drop down
      // Get the dropdown elements
      const minConductivityDropdown =
        document.getElementById("minConductivity");
      const minTensileStrengthDropdown =
        document.getElementById("minTensileStrength");

      // Add event listeners
      minConductivityDropdown.addEventListener("change", filterMyData);
      minTensileStrengthDropdown.addEventListener("change", filterMyData);

      function filterMyData() {
        const minConductivity = Number(minConductivityDropdown.value);
        const minTensileStrength = Number(minTensileStrengthDropdown.value);

        

        // Loop through the base cubes
        cubes.forEach((cube) => {
          console.log(cube.userData.type);
          if (cube.userData.type.includes("Alloy Conductors")) {
            console.log(cube.userData.y_conduct_e, cube.userData.x_tensile_e);

            if (
              cube.userData.y_conduct_e >= minConductivity &&
              cube.userData.x_tensile_e >= minTensileStrength
            ) {
              cube.visible = true;
              cube.userData.labelElement.style.display = 'block'; 
            } else {
              cube.visible = false;
              cube.userData.labelElement.style.display = 'none'; 
            }
          }
        });

        // Loop through the other cubes
        allCubes.forEach((cube) => {
          // Find the base cube that corresponds to this cube
          const baseCubeId = cube.userData.baseCubeId;
          const baseCube = cubes.find((c) => c.userData.id === baseCubeId);

          if (baseCube && baseCube.visible === false) {
            cube.visible = false;
          } else {
            cube.visible = true;
          }
        });

        // Add this line to re-render the scene
        //renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
